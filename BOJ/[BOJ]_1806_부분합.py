'''
[투 포인터 알고리즘 O(N)]
리스트에 순차적으로 접근해야 할 때 두 점의 위치를 기록하며 처리하는 알고리즘.
이 때, 두 점은 시작점과 끝 점을 의미한다.

* 기본 절차
1. 시작점과 끝점이 첫 인덱스(0)를 가리키게 한다.
2. 현재 부분합 == M이면 ans+1
3. 현재 부분합 < M이면 끝점 인덱스 +1
4. 현재 부분합 >= M이면 시작점 인덱스 +1
5. 조건에 맞는 결과 나올 때까지 2~4 반복

해당 문제에서는 충족하는 부분합의 개수가 아닌,
부분합 >= m 일 때 조건을 충족하는 리스트들 중,
길이가 가장 짧은 값을 내는 문제였음.
'''

n, m = map(int,input().split())
lst = list(map(int,input().split()))

end = 0
ans = n+1
sm = 0
cnt = 0  # 리스트 길이 변수

# start 증가시키며 반복
for start in range(n):
    # 부분합 < m 일 때, 끝점 +1, 길이 +1
    while sm<m and end<n:
        sm += lst[end]
        end += 1
        cnt += 1

    # 부분합 >= m 일 때, 리스트 최소 길이 비교 후 저장
    if sm >= m:
        if cnt < ans:
            ans = cnt

    # if문 끝났다면 시작점 -1, 길이 -1 
    sm -= lst[start]
    cnt -= 1

if ans == n+1:
    print(0)
else:
    print(ans)

'''
보통 최솟값 구할 때 충분히 큰 수 INF를 사용하는데
부분합의 경우 전체 리스트의 길이를 넘어가진 않을 테니까 n+1로 해주었다.

문제를 정확하게 읽지 않아서 부분합이 m이 되는 경우만 계산해서 틀렸고,
그 뒤로는 결과를 도출할 때 리스트의 길이 len(lst[start:end])로 계산해서 시간초과.
=> cnt를 증감하며 리스트 길이를 계산했더니 해결! 

'''

